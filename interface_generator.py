from numpy.linalg import det, norm, inv
from numpy import dot, cross, square, ceil, cos, sin
from pymatgen.core.structure import Structure
from pymatgen.io.cif import CifWriter
from pymatgen.io.vasp.inputs import Poscar
import numpy as np
import sys
from .cellcalc import MID, DSCcalc, get_primitive_hkl, get_right_hand, find_integer_vectors, get_pri_vec_inplane
import os

def rot(a, Theta):
    #produces a rotation matrix.
    c = float(cos(Theta))
    s = float(sin(Theta))
    a = a / norm(a)
    ax, ay, az = a
    return np.array([[c + ax * ax * (1 - c), ax * ay * (1 - c) - az * s,
                      ax * az * (1 - c) + ay * s],
                    [ay * ax * (1 - c) + az * s, c + ay * ay * (1 - c),
                        ay * az * (1 - c) - ax * s],
                     [az * ax * (1 - c) - ay * s, az * ay * (1 - c) + ax * s,
                      c + az * az * (1 - c)]], dtype = np.float64)

def rational_mtx(M, N):
    """
    find a rational matrix close to M
    arguments:
    M --- original matrix
    N --- denominator
    return --- a rational matrix
    """
    B = np.eye(3)
    for i in range(3):
        for j in range(3):
            B[i][j] = round(N * M[i][j])
    return B, N
 
def three_dot(M1, M2, M3):
    """
    compute the three continuous dot product
    """
    return dot(dot(M1,M2),M3)

def ang(v1, v2):
    """
    compute the cos of angle 
    """
    return abs(dot(v1, v2)/norm(v1)/norm(v2))

def get_ang_list(m1, n):
    """
    compute a list of ang cos between one arrays of vecor and one vector
    """
    return 1 / norm(n) * dot(m1, n) / norm(m1, axis = 1)
    
def cross_plane(lattice, n, lim, orthogonal, tol):
    """
    get a primitive lattice vector cross a plane
    argument:
    lattice --- lattice matrix
    n --- a normal vector
    lim --- control how many vectors to be generated
    tol --- tolerance judging orthogonal
    """
    x = np.arange(-lim, lim, 1)
    y = x
    z = x
    indice = (np.stack(np.meshgrid(x, y, z)).T).reshape(len(x) ** 3, 3)
    indice_0 = indice[np.where(np.sum(abs(indice), axis=1) != 0)[0]]
    indice_0 = indice_0[np.where(np.gcd.reduce(indice_0, axis=1) == 1)[0]] 
    ltc_p = dot(indice_0, lattice.T)
    ltc_p = ltc_p[np.argsort(norm(ltc_p, axis=1))]
    dot_list = get_ang_list(ltc_p, n)
    if orthogonal == False:
        normal_v = ltc_p[dot_list >= 0.75][0]
    else:
        try:
            normal_v = ltc_p[np.where( abs(dot_list - 1) < tol )[0]][0]
        except:
            print('failed to find a vector cross the plane. try larger lim or smaller tol or use non-orthogonal cell')
            sys.exit()
    return normal_v

def get_sites_elements(structure):
    """
    get the coordinates of atoms and the elements
    argument:
    structure --- pymatgen structure class
    return:
    atoms --- atom coordinates
    elements --- list of element name of the atoms
    """
    atoms = np.array([0, 0, 0])
    elements = []
    for i in structure.sites:
        atoms = np.vstack((atoms, i.frac_coords))
        elements.append(i.species_string)
    atoms = np.delete(atoms, 0, axis = 0)
    return atoms, np.array(elements)

def POSCAR_to_cif(Poscar_name, Cif_name):
    """
    get the cif file for the structure in a POSCAR file
    """
    structure = Structure.from_file(Poscar_name)
    structure.to(filename=Cif_name)
    del structure
    
def write_POSCAR(lattice, atoms, elements, filename = 'POSCAR'):
    """
    write Poscar file
    argument:
    lattice --- lattice matrix
    atoms --- atoms coordinates
    elements --- list of element name of the atoms
    """
    element_species = np.unique(elements)
    atoms_list = []
    num_list = []
    for i in range(len(element_species)):
        atoms_this_element = atoms[np.where(elements == element_species[i])[0]]
        atoms_list.append(atoms_this_element)
        num_list.append(len(atoms_this_element))
    
    if len(element_species) > 1:
        atoms = np.array([[0,0,0]],dtype = float)
        for i in atoms_list:
            atoms = np.vstack((atoms,i))
        atoms = np.delete(atoms,0,axis = 0)
        
    with open(filename, 'w') as f:
        f.write('#POSCAR generated by IF_master \n')
        
        #matrix
        f.write("1\n")
        f.write('{0:.16f} {1:.16f} {2:.16f} \n'.format(lattice[:,0][0],lattice[:,0][1],lattice[:,0][2]))
        f.write('{0:.16f} {1:.16f} {2:.16f} \n'.format(lattice[:,1][0],lattice[:,1][1],lattice[:,1][2]))
        f.write('{0:.16f} {1:.16f} {2:.16f} \n'.format(lattice[:,2][0],lattice[:,2][1],lattice[:,2][2]))
        
        #elements
        for i in element_species:
            f.write(str(i) + ' ')
        f.write('\n')
        
        #num of atoms
        for i in num_list:
            f.write(str(i) + ' ')
        f.write('\n')
        f.write("Direct\n")
        np.savetxt(f, atoms, fmt='%.16f %.16f %.16f')
    f.close()

def cell_expands(lattice, atoms, elements, xyz):
    """
    expand certain lattice
    argument:
    lattice --- lattice matrix
    atoms --- list of atom fractional coordinates
    elements --- list of element name of the atoms
    xyz --- expansions
    return:
    lattice --- lattice matrix
    atoms --- atom coordinates
    elements --- list of element name of the atoms
    """
    mtx = lattice.copy()
    dimX, dimY, dimZ = xyz
    x_shifts = np.arange(dimX)
    y_shifts = np.arange(dimY)
    z_shifts = np.arange(dimZ)
    
    dim_array = np.array([dimX,dimY,dimZ])
    g1_shifts = np.array(np.meshgrid(x_shifts, y_shifts, z_shifts)).T.reshape(-1, 3)
    atoms_expand = atoms.repeat(len(g1_shifts), axis=0) + np.tile(g1_shifts, (len(atoms), 1))
    elements = elements.repeat(len(g1_shifts))
    for i in range(3):
        atoms_expand[:,i] = atoms_expand[:,i]/xyz[i]
        mtx[:,i] = mtx[:,i] * xyz[i]
    return mtx, atoms_expand, elements

def get_array_bounds(U):
    """
    get the maximum & minimum number in the three directions of a matrix,
    and generate three arrays of indices
    argument:
    U --- matrix of linear combination making super cell
    """
    Mo = U.copy()
    # get the coordinates of 8 vertices
    P1 = [0,0,0]
    P2 = Mo[:,0]
    P3 = Mo[:,1]
    P4 = Mo[:,2]
    P5 = P2 + P3
    P6 = P2 + P4
    P7 = P3 + P4
    P8 = P2 + P3 + P4
    Points = np.vstack((P1,P2,P3,P4,P5,P6,P7,P8)) 
    # enclose the 8 verticies
    min1 = np.round(min(Points[:,0]-1),0)
    max1 = np.round(max(Points[:,0]+1),0)

    min2 = np.round(min(Points[:,1]-1),0)
    max2 = np.round(max(Points[:,1]+1),0)

    min3 = np.round(min(Points[:,2]-1),0)
    max3 = np.round(max(Points[:,2]+1),0)
    a = np.array([[min1,max1], [min2,max2], [min3,max3]])

    x = np.arange(min1 - 2, max1 + 2, 1)
    y = np.arange(min2 - 2, max2 + 2, 1)
    z = np.arange(min3 - 2, max3 + 2, 1)

    indice = (np.stack(np.meshgrid(x, y, z)).T).reshape(len(x) * len(y) * len(z), 3)
    return indice

def super_cell(U ,lattice, Atoms, elements):
    """
    make supercell
    argument:
    U --- coefficients of the LC of three vectors from the basis
    atoms --- fractional coordinates of atoms
    elements --- list of the element names of these atoms
    return:
    lattice --- lattice matrix
    atoms --- atom coordinates
    elements --- list of element name of the atoms
    """
    indice = get_array_bounds(U)
    
    #1.get atoms
    Atoms = Atoms.repeat(len(indice),axis=0) + np.tile(indice,(len(Atoms),1))
    elements = elements.repeat(len(indice))
    tol = 1e-10
    
    #3.delete atoms dropping outside
    Atoms = dot(inv(U),Atoms.T).T
    Atoms_try = Atoms.copy()
    Atoms_try = Atoms + [tol, tol, tol]
    con = (Atoms_try[:,0] < 1) & (Atoms_try[:,0] >= 0) \
        & (Atoms_try[:,1] < 1) & (Atoms_try[:,1] >= 0) \
        & (Atoms_try[:,2] < 1) & (Atoms_try[:,2] >= 0) 
    indices = np.where(con)[0]
    Atoms = Atoms[indices]
    elements = elements[indices]
    lattice = dot(lattice, U)
    return Atoms, elements, lattice

def shift_terminate(lattice, dp, atoms):
    """
    apply RBT along certain lattice vector to change the terminating planes
    argument:
    lattice --- lattice matrix
    dp --- RBT along the vector cross the plane
    atoms --- atom fractional coordinates
    """
    n = cross(lattice[:,1],lattice[:,2])
    position_shift = dp / ang(lattice[:,0], n) / norm(lattice[:,0])
    atoms[:,0] = atoms[:,0] + position_shift
    atoms[:,0] = atoms[:,0] - np.floor(atoms[:,0])

def excess_volume(lattice_1, lattice_bi, atoms_1, atoms_2, dx):
    """
    introduce vacuum between the interfaces
    argument:
    lattice_1 --- lattice matrix of the first slab
    lattice_bi --- lattice matrix of the bicrystal
    atoms_1, atoms_2 --- atom fractional coordinates of slab 1, slab 2
    dx --- length of expands normal to the interface with the same units as lattice para
    """
    n = cross(lattice_1[:,1],lattice_1[:,2])
    normal_shift = dx / ang(lattice_1[:,0], n) / norm(lattice_1[:,0])
    lattice_bi[:,0] = (2 * normal_shift + 1) * lattice_bi[:,0]
    atoms_1[:,0] = 1 / (2 * normal_shift + 1) * atoms_1[:,0]
    atoms_2[:,0] = 1 / (2 * normal_shift + 1) * atoms_2[:,0]
    atoms_2[:,0] = atoms_2[:,0] + normal_shift * atoms_2[:,0]

def surface_vacuum(lattice_1, lattice_bi, atoms_bi, vx):
    """
    introduce vacuum at one of the tails of the bicrystal cell
    argument:
    lattice_1 --- lattice matrix of the first slab
    lattice_bi --- lattice matrix of the bicrystal
    atoms_bi --- atom fractional coordinates of the bicrystal
    vx --- length of the vacuum bulk with units as lattice para
    """   
    n = cross(lattice_1[:,1],lattice_1[:,2])
    normal_shift = vx / ang(lattice_1[:,0], n) / norm(lattice_1[:,0])
    lattice_bi[:,0] = lattice_bi[:,0] * (1 + normal_shift)
    atoms_bi[:,0] = 1 / (1 + normal_shift) * atoms_bi[:,0]

def unit_cell_axis(axis):
    """
    get an unit orthogonal cell specified one vector axis
    """
    v1 = axis / norm(axis)
    v2 = np.array([0,0,0],dtype = float)
    v2[0], v2[1] = -v1[1], v1[0]
    v2 = v2 / norm(v2)
    v3 = cross(v1, v2)
    v3 = v3 / norm(v3)
    B = np.column_stack((v1,v2,v3))
    B = get_right_hand(B)
    return B
    
def unit_v(vector):
    """
    get the unit vector of a vector
    """
    return vector / norm(vector)

def adjust_orientation(lattice):
    """
    adjust the orientation of a lattice so that its first axis is along
    x-direction and the second axis is in the x-y plane
    """
    v1 = lattice[:,0]
    v3 = cross(lattice[:,0],lattice[:,1])
    v2 = cross(v1,v3)
    
    v1, v2, v3 = unit_v(v1), unit_v(v2), unit_v(v3)
    this_orientation = np.column_stack((v1,v2,v3))
    desti_orientation = np.eye(3)
    R = dot(desti_orientation, inv(this_orientation))
    lattice = dot(R, lattice)
    return lattice
    
def convert_vector_index(lattice_0, lattice_f, v_0):
    """
    convert the index of a vector into a different basis
    """
    v_0 = dot(lattice_0, v_0)
    v_f = dot(inv(lattice_f), v_0)
    return v_f

def print_near_axis(dv, lattice_1, lattice_2, lim=5):
    """
    searching for near coincident lattice vectors
    """
    x = np.arange(-lim, lim, 1)
    y = x
    z = x
    tol = 1e-10
    indice = (np.stack(np.meshgrid(x, y, z)).T).reshape(len(x) ** 3, 3)
    indice_0 = indice[np.where(np.sum(abs(indice), axis=1) != 0)[0]] 
    num = len(indice_0)
    ltc_p_1 = dot(indice_0, lattice_1.T)
    ltc_p_2 = dot(indice_0, lattice_2.T)
    
    v_index_1 = np.arange(num).repeat(num)
    v_index_2 = np.tile(np.arange(num), num)
    ltc_p_1_rep = ltc_p_1.repeat(num, axis = 0)
    ltc_p_2_rep = np.tile(ltc_p_2, (num,1))

    distances = abs(norm(ltc_p_1_rep, axis = 1) - norm(ltc_p_2_rep, axis=1))
    close_ids = np.where(distances <= dv)[0]
    
    close_vecs_1 = ltc_p_1_rep[close_ids]
    close_vecs_2 = ltc_p_2_rep[close_ids]
    close_vecs_2 = close_vecs_2[np.argsort(norm(close_vecs_1,axis = 1))]
    close_vecs_1 = close_vecs_1[np.argsort(norm(close_vecs_1,axis = 1))]
    
    print('       e1        e2       dv      length_v1    length_v2')
    for i in range(len(close_vecs_1)):
        e1 = np.round(dot(inv(lattice_1),close_vecs_1[i]),8)
        e2 = np.round(dot(inv(lattice_2),close_vecs_2[i]),8)
        dv = abs(norm(close_vecs_1[i]) - norm(close_vecs_2[i]))
        norm_1 = norm(close_vecs_1[i])
        norm_2 = norm(close_vecs_2[i])
        print(e1, e2, dv, norm_1, norm_2)
        
class core:
    def __init__(self, file_1, file_2):
        self.afile_1 = file_1 # cif file name of lattice 1
        self.file_2 = file_2 # cif file name of lattice 2
        self.structure_1 = Structure.from_file(file_1, primitive=True, sort=False, merge_tol=0.0)
        self.structure_2 = Structure.from_file(file_2, primitive=True, sort=False, merge_tol=0.0)
        
        self.conv_lattice_1 = Structure.from_file(file_1, primitive=False, sort=False, merge_tol=0.0) \
                                .lattice.matrix.T
        
        self.conv_lattice_2 = Structure.from_file(file_2, primitive=False, sort=False, merge_tol=0.0) \
                                .lattice.matrix.T
        
        self.lattice_1 = self.structure_1.lattice.matrix.T
        self.lattice_2 = self.structure_2.lattice.matrix.T
        self.lattice_2_TD = self.structure_2.lattice.matrix.T.copy()
        self.CSL = np.eye(3) # CSL cell in cartesian
        self.du = 0.005 
        self.S = 0.005
        self.D = np.eye(3)
        self.sgm1 = 100 # sigma 1
        self.sgm2 = 100 # sigma 2
        self.R = np.eye(3) # rotation matrix
        self.axis = np.array([0.0,0.0,0.0]) # rotation axis
        self.theta = 0.0 # rotation angle
        self.U1 = np.eye(3)
        self.U2 = np.eye(3)
        self.bicrystal_U1 = np.eye(3) # indices of the slab of lattice 1
        self.bicrystal_U2 = np.eye(3) # indices of the slab of lattice 2
        self.CNID = np.eye(3,2)
        self.cell_calc = DSCcalc()
        self.name = str
        self.dd = float
        self.orientation = np.eye(3) # initial disorientation
        #get the atoms in the primitive cell
        self.atoms_1, self.elements_1 = get_sites_elements(self.structure_1)
        self.atoms_2, self.elements_2 = get_sites_elements(self.structure_2)
        print('Warning!, this programme will rewrite the POSCAR file in this dir!')
        
    def parse_limit(self, du, S, sgm1, sgm2, dd):
        """
        set the limitation to accept an appx CSL
        arguments -- see the paper
        """
        self.du = du
        self.S = S
        self.sgm1 = sgm1
        self.sgm2 = sgm2
        self.dd = dd
        
    def search_one_position(self, axis, theta, theta_range, dtheta):
        """
        main loop finding the appx CSL
        arguments:
        axis -- rotation axis
        theta -- initial rotation angle, in degree
        theta_range -- range varying theta, in degree
        dtheta -- step varying theta, in degree
        """
        axis = dot(self.lattice_1, axis)
        file = open('log.one_position','w')
        theta = theta / 180 * np.pi
        n = ceil(theta_range/dtheta)
        dtheta = theta_range / n / 180 * np.pi
        x = np.arange(n)
        Ns = np.arange(1, self.sgm2 + 1)
        found = None
        a1 = self.lattice_1.copy()
        a2_0 = self.lattice_2.copy()
        # rotation loop
        file.write('---Searching starts---\n')
        file.write('axis theta dtheta n S du sigma1_max sigma2_max\n')
        file.write('{0} {1} {2} {3} {4} {5} {6} {7}\n'.\
              format(axis, theta, dtheta, n, self.S, self.du, self.sgm1, self.sgm2))
        file.write('-----------for theta-----------\n')
        for i in x:
            N = 1
            R = dot(self.orientation, rot(axis, theta))
            U = three_dot(inv(a1), R, a2_0)
            file.write('theta = ' + str(theta / np.pi * 180) + '\n')
            file.write('    -----for N-----\n')
            while N <= self.sgm2:
                tol = 1e-10
                Uij, N = rational_mtx(U,N)
                U_p = 1 / N * Uij
                #print("du'max = " + str(np.max(abs(U_p - U))))
                #no_zero = norm(U_p[:,0]) > tol and norm(U_p[:,1]) > tol and norm(U_p[:,2]) > tol
                #if np.all((abs(U_p-U)) < self.du) and no_zero:
                if np.all((abs(U_p-U)) < self.du):
                    file.write('    N= ' + str(N) + " accepted" + '\n')
                    R_p = three_dot(a1, U_p, inv(a2_0))
                    D = dot(inv(R),R_p)
                    if (abs(det(D)-1) <= self.S) and \
                    np.all(abs(D-np.eye(3)) < self.dd):
                        here_found = True
                        file.write('    --D accepted--\n')
                        file.write("    D, det(D) = {0} \n".format(det(D)))
                        ax2 = three_dot(R,D,a2_0)
                        calc = DSCcalc()
                        try:
                            calc.parse_int_U(a1, ax2, self.sgm2)
                            calc.compute_CSL()
                        except:
                            file.write('    failed to find CSL here \n')
                            here_found = False
                        if here_found and abs(det(calc.U1)) <= self.sgm1:
                            found = True
                            file.write('--------------------------------\n')
                            file.write('Congrates, we found an appx CSL!\n')
                            sigma1 = int(abs(np.round(det(calc.U1))))
                            sigma2 = int(abs(np.round(det(calc.U2))))
                            self.D = D
                            self.U1 = np.array(np.round(calc.U1),dtype = int)
                            self.U2 = np.array(np.round(calc.U2),dtype = int)
                            self.lattice_2_TD = three_dot(R, D, a2_0)
                            self.CSL = dot(self.lattice_1, self.U1)
                            self.R = R
                            self.theta = theta
                            self.axis = axis
                            self.cell_calc = calc
                            
                            file.write('U1 = \n' + \
                                       str(self.U1) + '; sigma_1 = ' + \
                                       str(sigma1) + '\n')
                            
                            file.write('U2 = \n' + str(self.U2) + '; sigma_2 = ' \
                                       + str(sigma1) + '\n')
                            
                            file.write('D = \n' + str(np.round(D,8)) + '\n')
                            
                            file.write('axis = ' + str(axis) + ' ; theta = ' \
                                       + str(np.round(theta / np.pi * 180,8)) \
                                       + '\n')
                            
                            print('Congrates, we found an appx CSL!\n')
                            print('U1 = \n' + \
                                       str(self.U1) + '; sigma_1 = ' + \
                                       str(sigma1) + '\n')
                            
                            print('U2 = \n' + str(self.U2) + '; sigma_2 = ' \
                                       + str(sigma1) + '\n')
                            
                            print('D = \n' + str(np.round(D,8)) + '\n')
                            
                            print('axis = ' + str(axis) + ' ; theta = ' \
                                       + str(np.round(theta / np.pi * 180,8)) \
                                       + '\n')
                            
                            break
                        else:
                            file.write('    sigma too large \n')
                N += 1
            if found:
                break
            theta += dtheta
        if not found:
            print('failed to find a satisfying appx CSL. Try to adjust the limits according \
                  to the log file generated; or try another orientation.')
        
    def get_bicrystal(self, dydz = np.array([0.0,0.0,0.0]), dx = 0, dp1 = 0, dp2 = 0, \
                      xyz = [1,1,1], vx = 0, filename = 'POSCAR'):
        """
        generate a cif file for the bicrystal structure
        argument:
        dydz --- translation vector in the interface
        dx --- translation normal to the interface
        dp1 --- termination of slab 1
        dp2 --- termination of slab 2
        xyz --- expansion
        """
        #get the atoms in the primitive cell
        lattice_1, atoms_1, elements_1 = self.lattice_1.copy(), self.atoms_1.copy(), self.elements_1.copy()
        lattice_2, atoms_2, elements_2 = self.lattice_2.copy(), self.atoms_2.copy(), self.elements_2.copy()
        
        # deform & rotate lattice_2
        lattice_2 = three_dot(self.R, self.D, lattice_2)
        
        #make supercells of the two slabs
        atoms_1, elements_1, lattice_1 = super_cell(self.bicrystal_U1, \
                                                    lattice_1, atoms_1, elements_1)
        atoms_2, elements_2, lattice_2 = super_cell(self.bicrystal_U2, \
                                                    lattice_2, atoms_2, elements_2)

        #termination
        if dp1 > 0:
            shift_terminate(lattice_1, dp1, atoms_1)
        if dp2 > 0:
            shift_terminate(lattice_2, dp2, atoms_2)
        
        #expansion
        if not np.all(xyz == 1):
            lattice_1, atoms_1, elements_1 = cell_expands(lattice_1, atoms_1, \
                                                          elements_1, xyz)
            lattice_2, atoms_2, elements_2 = cell_expands(lattice_2, atoms_2, \
                                                          elements_2, xyz)
        
        #adjust the orientation
        lattice_1 = adjust_orientation(lattice_1)
        lattice_2 = adjust_orientation(lattice_2)
        
        write_POSCAR(lattice_1, atoms_1, elements_1, 'POSCAR')
        POSCAR_to_cif('POSCAR','cell_1.cif')
        write_POSCAR(lattice_2, atoms_2, elements_2, 'POSCAR')
        POSCAR_to_cif('POSCAR','cell_2.cif')
        os.remove('POSCAR')

        #combine the two lattices and translate atoms
        lattice_bi = lattice_1.copy()
        lattice_bi[:,0] = 2 * lattice_bi[:,0]
        atoms_1[:,0] = atoms_1[:,0] / 2
        atoms_2[:,0] = (atoms_2[:,0] + 1) / 2
        
        #excess volume
        if dx != 0:
            excess_volume(lattice_1, lattice_bi, atoms_1, atoms_2, dx)
                    
        #in-plane translation
        if norm(dydz) > 0:
            plane_shift = dot(inv(lattice_bi), dydz)
            atoms_2 = atoms_2 + plane_shift
            
        #combine the two slabs
        elements_bi = np.append(elements_1, elements_2)
        atoms_bi = np.vstack((atoms_1, atoms_2))
        
        #vacummn
        if vx > 0:
            surface_vacuum(lattice_1, lattice_bi, atoms_bi, vx)
            
        write_POSCAR(lattice_bi, atoms_bi, elements_bi, filename)
    
    def sample_CNID(self, grid, dx = 0, dp1 = 0, dp2 = 0, \
                      xyz = [1,1,1], vx = 0, filename = 'POSCAR'):
        """
        sampling the CNID and generate POSCARs
        argument:
        grid --- 2D grid of sampling
        """
        print('CNID')
        print(np.round(dot(inv(self.lattice_1),self.CNID),8))
        print('making {} files'.format(grid[0] * grid[1]) + '...')
        n1 = grid[0]
        n2 = grid[1]
        v1, v2 = self.CNID.T
        for i in range(n1):
            for j in range(n2):
                dydz = v1 / n1 * i + v2 / n2 * j
                self.get_bicrystal(dydz = dydz, dx = dx, dp1 = dp1, dp2 = dp2, \
                      xyz = xyz, vx = vx, filename = filename + '.' + str(i) + '.' + str(j))
        print('completed')
        
    def set_orientation_axis(self, axis_1, axis_2):
        """
        rotate lattice_2 so that its axis_2 coincident with the axis_1 of lattice_1
        """
        axis_1 = dot(self.lattice_1, axis_1)
        axis_2 = dot(self.lattice_2, axis_2)
        
        cell_1 = unit_cell_axis(axis_1)
        cell_2 = unit_cell_axis(axis_2)

        R = dot(cell_1, inv(cell_2))
        self.lattice_2 = dot(R, self.lattice_2)
        self.orientation = R
        self.axis = axis_1

    def compute_bicrystal(self, hkl, lim = 20, orthogonal = False, tol = 1e-10):
        """
        compute the transformation to obtain the supercell of the two slabs forming a interface
        argument:
        hkl --- miller indices of the plane expressed in lattice_1
        lim --- the limit searching for a CSL vector cross the plane
        orthogonal --- whether to obtain a monoclinic supercell
        tol --- tolerance judging whether orthogonal
        """
        hkl_c = get_primitive_hkl(hkl, self.lattice_1, self.CSL) # miller indices of the plane in CSL
        hkl_c = np.array(hkl_c)
        plane_B = get_pri_vec_inplane(hkl_c, self.CSL) # plane bases of the CSL lattice plane
        plane_n = cross(plane_B[:,0], plane_B[:,1]) # plane normal
        v3 = cross_plane(self.CSL, plane_n, lim, orthogonal, tol) # a CSL basic vector cross the plane
        supercell = np.column_stack((v3, plane_B)) # supercell of the bicrystal
        supercell = get_right_hand(supercell) # check right-handed
        self.bicrystal_U1 = np.array(np.round(dot(inv(self.lattice_1), supercell),8),dtype = int)
        self.bicrystal_U2 = np.array(np.round(dot(inv(self.lattice_2_TD), supercell),8),dtype = int)
        self.cell_calc.compute_CNID(hkl)
        CNID = self.cell_calc.CNID
        self.CNID = dot(self.lattice_1, CNID)
        print('cell 1:')
        print(self.bicrystal_U1)
        print('cell 2:')
        print(self.bicrystal_U1)